/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/converter.js":
/*!**************************!*\
  !*** ./src/converter.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {SavReader} = __webpack_require__(/*! ./sav-reader */ \"./src/sav-reader.js\");\nconst {assignPrototype} = __webpack_require__(/*! ./properties */ \"./src/properties.js\");\n\nfunction convertSavToJson(savFileArrayBuffer) {\n    const parsedContent = new SavReader(savFileArrayBuffer).readWholeBuffer();\n    return JSON.stringify(parsedContent, null, 2);\n}\n\nfunction convertJsonToSav(jsonString) {\n    let output = new Uint8Array(0);\n\n    for (const property of JSON.parse(jsonString)) {\n        assignPrototype(property);\n        output = new Uint8Array([...output, ...property.toBytes()]);\n    }\n\n    return output;\n}\n\nmodule.exports = {\n    convertSavToJson,\n    convertJsonToSav\n};\n\n\n//# sourceURL=webpack://gvas-json-converter/./src/converter.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const {convertJsonToSav, convertSavToJson} = __webpack_require__(/*! ./converter */ \"./src/converter.js\");\nconst output_element = document.getElementById('output')\nconst output_div = document.getElementById('output-div')\nconst output_title = document.getElementById('output-title-div')\nconst run_buttons = document.getElementById('run-extract-insert')\nconst extract_button = document.getElementById('extract-run')\nconst body = document.getElementById('body')\nlet parsed_output;\nlet obj;\n\nfunction findObjectByName(obj, name) {\n    if (obj?.name === name) return obj;\n\n    for (let i in obj) {\n        if (typeof obj[i] === 'object') {\n            let found = findObjectByName(obj[i], name);\n            if (found) return found;\n        }\n    }\n\n    return null;\n}\n\nfunction replaceOrAddAutoSave(obj, newAutoSaveObj) {\n    if (Array.isArray(obj)) {\n        let autoSaveIndex = -1;\n        let fileEndPropertyIndex = -1;\n        \n        // Find indices of \"AutoSave\" and \"FileEndProperty\" objects in the array\n        for (let i = 0; i < obj.length; i++) {\n            if (obj[i]?.name === \"AutoSave\") autoSaveIndex = i;\n            if (obj[i]?.type === \"FileEndProperty\") fileEndPropertyIndex = i;\n        }\n\n        if (fileEndPropertyIndex !== -1) {\n            // \"FileEndProperty\" is found in this array\n            if (autoSaveIndex !== -1) {\n                // Replace \"AutoSave\" object if it's found\n                obj[autoSaveIndex] = newAutoSaveObj;\n            } else {\n                // Add \"AutoSave\" object before \"FileEndProperty\" if it's not found\n                obj.splice(fileEndPropertyIndex, 0, newAutoSaveObj);\n            }\n            return true; // Stop recursion once we've worked on the correct array\n        }\n    }\n\n    // If the current item is an object or array, recurse into it\n    for (let key in obj) {\n        if (obj[key] !== null && typeof obj[key] === \"object\") {\n            if (replaceOrAddAutoSave(obj[key], newAutoSaveObj)) return true;\n        }\n    }\n\n    return false;\n}\n\nfunction downloadJson(filename, jsonString) {\n    const element = document.createElement(\"a\");\n    element.setAttribute(\"href\", \"data:text/json;charset=utf-8,\" + encodeURIComponent(jsonString));\n    element.setAttribute(\"download\", filename);\n    element.click();\n}\n\nfunction downloadSav(filename, savArrayBuffer) {\n    const blob = new Blob([savArrayBuffer], {type: \"octet/stream\"});\n\n    const element = document.createElement(\"a\");\n    element.setAttribute(\"href\", window.URL.createObjectURL(blob));\n    element.setAttribute(\"download\", filename);\n    element.click();\n}\n\nfunction extractRunFile() {\n    let name = document.getElementById('run-name').value;\n    console.log(name)\n    if (obj && name !== '') {\n        downloadJson(name + '.json', JSON.stringify(obj, null, 2));\n    } else if (!obj) {\n        window.alert('No run found!')\n    } else {\n        window.alert('Enter a name!')\n    }\n}\n\nfunction insertRunFile() {\n    const fileReader = new FileReader();\n    fileReader.fileName = this.files[0].name;\n    let runObj;\n    fileReader.onload = function (e) {\n        runObj = JSON.parse(e.target.result);\n        replaceOrAddAutoSave(parsed_output, runObj);\n        obj = findObjectByName(parsed_output, 'AutoSave');\n\n        let jsonObj = JSON.stringify(obj, null, 2)\n        output_title.style.display = 'flex';\n        output_div.style.display = 'flex';\n        extract_button.style.display = 'flex'\n        body.style.overflow = 'auto';\n        output_element.textContent = jsonObj;\n\n        downloadSav('SaveSlot_New' + \".sav\", convertJsonToSav(JSON.stringify(parsed_output, null, 2)))\n    };\n\n    fileReader.readAsText(this.files[0]);\n}\n\nfunction loadSavFile() {\n    const fileReader = new FileReader();\n    fileReader.fileName = this.files[0].name;\n    extract_button.style.display = 'none';\n    fileReader.onload = function (e) {\n        let output = convertSavToJson(e.target.result);\n        parsed_output = JSON.parse(output)\n        obj = findObjectByName(parsed_output, 'AutoSave');\n        run_buttons.style.display = 'flex';\n\n        if (obj) {\n            let jsonObj = JSON.stringify(obj, null, 2)\n            console.log(output);\n            output_title.style.display = 'flex';\n            output_div.style.display = 'flex';\n            extract_button.style.display = 'flex';\n            body.style.overflow = 'auto';\n            output_element.textContent = jsonObj;\n        } else {\n            console.log('No object found with name', 'AutoSave');\n            output_title.style.display = 'none';\n            output_div.style.display = 'flex';\n            output_element.textContent = 'No run found in ' + fileReader.fileName;\n        }\n        \n        // downloadJson(fileReader.fileName + \".json\", convertSavToJson(e.target.result));\n    };\n\n    fileReader.readAsArrayBuffer(this.files[0]);\n}\n\nfunction loadJsonFile() {\n    const fileReader = new FileReader();\n    fileReader.fileName = this.files[0].name;\n\n    fileReader.onload = function (e) {\n        downloadSav(fileReader.fileName + \".sav\", convertJsonToSav(e.target.result));\n    };\n\n    fileReader.readAsText(this.files[0]);\n}\n\ndocument.getElementById(\"sav-input\").addEventListener(\"change\", loadSavFile);\ndocument.getElementById(\"json-input\").addEventListener(\"change\", loadJsonFile);\ndocument.getElementById(\"insert-input\").addEventListener(\"change\", insertRunFile);\ndocument.getElementById(\"extract-output\").addEventListener(\"click\", extractRunFile);\n\n\n//# sourceURL=webpack://gvas-json-converter/./src/main.js?");

/***/ }),

/***/ "./src/properties.js":
/*!***************************!*\
  !*** ./src/properties.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n    writeInt32,\n    writeUint32,\n    writeString,\n    writeFloat32,\n    writeBytes,\n    writeDateTime,\n    writeInt16\n} = __webpack_require__(/*! ./sav-writer */ \"./src/sav-writer.js\");\n\nfunction assignPrototype(rawProperty) {\n    switch (rawProperty.type) {\n        case \"HeaderProperty\":\n            return Object.setPrototypeOf(rawProperty, HeaderProperty.prototype);\n        case \"NoneProperty\":\n            return Object.setPrototypeOf(rawProperty, NoneProperty.prototype);\n        case \"BoolProperty\":\n            return Object.setPrototypeOf(rawProperty, BoolProperty.prototype);\n        case \"IntProperty\":\n            return Object.setPrototypeOf(rawProperty, IntProperty.prototype);\n        case \"UInt32Property\":\n            return Object.setPrototypeOf(rawProperty, UInt32Property.prototype);\n        case \"StrProperty\":\n            return Object.setPrototypeOf(rawProperty, StrProperty.prototype);\n        case \"NameProperty\":\n            return Object.setPrototypeOf(rawProperty, NameProperty.prototype);\n        case \"ByteProperty\":\n            return Object.setPrototypeOf(rawProperty, ByteProperty.prototype);\n        case \"EnumProperty\":\n            return Object.setPrototypeOf(rawProperty, EnumProperty.prototype);\n        case \"FloatProperty\":\n            return Object.setPrototypeOf(rawProperty, FloatProperty.prototype);\n        case \"StructProperty\":\n            return Object.setPrototypeOf(rawProperty, StructProperty.prototype);\n        case \"ArrayProperty\":\n            return Object.setPrototypeOf(rawProperty, ArrayProperty.prototype);\n        case \"MulticastInlineDelegateProperty\":\n            return Object.setPrototypeOf(rawProperty, MulticastInlineDelegateProperty.prototype);\n        case \"MapProperty\":\n            return Object.setPrototypeOf(rawProperty, MapProperty.prototype);\n        case \"SetProperty\":\n            return Object.setPrototypeOf(rawProperty, SetProperty.prototype);\n        case \"ObjectProperty\":\n            return Object.setPrototypeOf(rawProperty, ObjectProperty.prototype);\n        case \"FileEndProperty\":\n            return Object.setPrototypeOf(rawProperty, FileEndProperty.prototype);\n        default:\n            throw new Error(\"Unknown property type: \" + rawProperty.type);\n    }\n}\n\nclass HeaderProperty {\n    static GVAS = new Uint8Array([0x47, 0x56, 0x41, 0x53]);\n    type = \"HeaderProperty\";\n\n    constructor(savReader) {\n        savReader.readBytes(HeaderProperty.GVAS.length);\n        this.saveGameVersion = savReader.readInt32();\n        this.packageVersion = savReader.readInt32();\n\n        this.engineVersion = savReader.readInt16() + \".\" + savReader.readInt16() + \".\" + savReader.readInt16();\n        this.engineBuild = savReader.readUInt32();\n        this.engineBranch = savReader.readString();\n\n        this.customVersionFormat = savReader.readInt32();\n        const numberOfCustomVersions = savReader.readInt32();\n        const tempMap = new Map();\n\n        for (let i = 0; i < numberOfCustomVersions; i++) {\n            tempMap.set(savReader.readBytes(16), savReader.readInt32());\n        }\n\n        this.customVersions = Array.from(tempMap.entries());\n        this.saveGameClassName = savReader.readString();\n    }\n\n    toBytes() {\n        let resultArray = new Uint8Array([\n            ...HeaderProperty.GVAS,\n            ...writeInt32(this.saveGameVersion),\n            ...writeInt32(this.packageVersion),\n            ...writeInt16(this.engineVersion.split(\".\")[0]),\n            ...writeInt16(this.engineVersion.split(\".\")[1]),\n            ...writeInt16(this.engineVersion.split(\".\")[2]),\n            ...writeUint32(this.engineBuild),\n            ...writeString(this.engineBranch),\n            ...writeInt32(this.customVersionFormat),\n            ...writeInt32(this.customVersions.length)\n        ]);\n\n        for (let i = 0; i < this.customVersions.length; i++) {\n            resultArray = new Uint8Array([...resultArray,\n                ...writeBytes(this.customVersions[i][0]),\n                ...writeInt32(this.customVersions[i][1])\n            ]);\n        }\n\n        resultArray = new Uint8Array([...resultArray, ...writeString(this.saveGameClassName)]);\n        return resultArray;\n    }\n}\n\nclass NoneProperty {\n    static bytes = new Uint8Array([0x05, 0x00, 0x00, 0x00, 0x4E, 0x6F, 0x6E, 0x65, 0x00]);\n    type = \"NoneProperty\";\n\n    toBytes() {\n        return NoneProperty.bytes;\n    }\n}\n\nclass FileEndProperty {\n    static bytes = new Uint8Array([...NoneProperty.bytes, 0x00, 0x00, 0x00, 0x00]);\n    type = \"FileEndProperty\";\n\n    toBytes() {\n        return FileEndProperty.bytes;\n    }\n}\n\nclass BoolProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"BoolProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        savReader.readBytes(BoolProperty.padding.length);\n        this.value = savReader.readBoolean();\n        savReader.readBytes(1);\n    }\n\n    toBytes() {\n        let result = new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...BoolProperty.padding\n        ]);\n\n        if (this.value === true) {\n            result = new Uint8Array([...result, 0x01]);\n        } else {\n            result = new Uint8Array([...result, 0x00]);\n        }\n\n        return new Uint8Array([...result, 0x00]);\n    }\n}\n\nclass IntProperty {\n    static padding = new Uint8Array([\n        0x04, // ?\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"IntProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        savReader.readBytes(IntProperty.padding.length);\n        this.value = savReader.readInt32();\n    }\n\n    toBytes() {\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...IntProperty.padding,\n            ...writeInt32(this.value)\n        ]);\n    }\n}\n\nclass UInt32Property {\n    static padding = new Uint8Array([\n        0x04, // ?\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"UInt32Property\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        savReader.readBytes(UInt32Property.padding.length);\n        this.value = savReader.readUInt32();\n    }\n\n    toBytes() {\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...UInt32Property.padding,\n            ...writeUint32(this.value)\n        ]);\n    }\n}\n\nclass StrProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"StrProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        this.unknown = savReader.readBytes(1);\n        savReader.readBytes(StrProperty.padding.length);\n        this.value = savReader.readString();\n    }\n\n    toBytes() {\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeBytes(this.unknown),\n            ...StrProperty.padding,\n            ...writeString(this.value)\n        ]);\n    }\n}\n\nclass NameProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"NameProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        this.unknown = savReader.readBytes(1);\n        savReader.readBytes(NameProperty.padding.length);\n        this.value = savReader.readString();\n    }\n\n    toBytes() {\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeBytes(this.unknown),\n            ...NameProperty.padding,\n            ...writeString(this.value)\n        ]);\n    }\n}\n\nclass ByteProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n    static unknown = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"ByteProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        const contentSize = savReader.readUInt32();\n        savReader.readBytes(4); // padding\n        this.subtype = savReader.readString();\n        savReader.readBytes(1);\n\n        switch (this.subtype) {\n            case \"StructProperty\":\n                const contentCount = savReader.readUInt32();\n\n                const nameAgain = savReader.readString();\n                if (nameAgain !== this.name) throw new Error();\n\n                const subtypeAgain = savReader.readString();\n                if (subtypeAgain !== this.subtype) throw new Error();\n\n                savReader.readUInt32(); // arraySize\n                savReader.readBytes(4); // padding\n\n                this.genericType = savReader.readString();\n\n                const unknown = savReader.readBytes(17);\n                if (unknown !== \"0000000000000000000000000000000000\") throw new Error();\n\n                this.value = [];\n\n                switch (this.genericType) {\n                    case \"Guid\":\n                        for (let i = 0; i < contentCount; i++) {\n                            this.value.push(savReader.readBytes(16));\n                        }\n                        break;\n\n                    default:\n\n                        for (let i = 0; i < contentCount; i++) {\n                            const structElementInstance = [];\n\n                            let structElementInstanceChildProperty = null;\n\n                            while (!(structElementInstanceChildProperty instanceof NoneProperty)) {\n                                structElementInstanceChildProperty = savReader.readProperty();\n                                structElementInstance.push(structElementInstanceChildProperty);\n\n                            }\n\n                            this.value.push(structElementInstance);\n                        }\n                }\n\n                break;\n\n            default:\n                this.value = savReader.readBytes(contentSize);\n        }\n    }\n\n    toBytes() {\n        const contentCount = this.value.length;\n        let byteArrayContent = new Uint8Array(0);\n\n        let contentSize;\n\n        switch (this.subtype) {\n            case \"StructProperty\":\n\n                switch (this.genericType) {\n                    case \"Guid\":\n                        for (let i = 0; i < contentCount; i++) {\n                            byteArrayContent = new Uint8Array([...byteArrayContent, ...writeBytes(this.value[i])]);\n                        }\n                        break;\n\n                    default:\n                        for (let i = 0; i < contentCount; i++) {\n\n                            if (Array.isArray(this.value[i])) {\n                                for (let j = 0; j < this.value[i].length; j++) {\n                                    assignPrototype(this.value[i][j]);\n                                    byteArrayContent = new Uint8Array([...byteArrayContent, ...this.value[i][j].toBytes()]);\n                                }\n                            } else {\n                                assignPrototype(this.value[i]);\n                                byteArrayContent = new Uint8Array([...byteArrayContent, ...this.value[i].toBytes()]);\n                            }\n                        }\n                }\n\n                contentSize =\n                    4\n                    + 4 + this.name.length + 1\n                    + 4 + this.subtype.length + 1\n                    + 4\n                    + ByteProperty.padding.length\n                    + 4 + this.genericType.length + 1\n                    + ByteProperty.unknown.length\n                    + byteArrayContent.length;\n\n                return new Uint8Array([\n                    ...writeString(this.name),\n                    ...writeString(this.type),\n                    ...writeUint32(contentSize),\n                    ...ByteProperty.padding,\n                    ...writeString(this.subtype),\n                    0x00, // --- contentSize content below ---\n                    ...writeUint32(contentCount),\n                    ...writeString(this.name),\n                    ...writeString(this.subtype),\n                    ...writeUint32(byteArrayContent.length),\n                    ...ByteProperty.padding,\n                    ...writeString(this.genericType),\n                    ...ByteProperty.unknown,\n                    ...byteArrayContent\n                ]);\n\n            default:\n                contentSize = this.value.length / 2;\n                return new Uint8Array([\n                    ...writeString(this.name),\n                    ...writeString(this.type),\n                    ...writeUint32(contentSize),\n                    ...ByteProperty.padding,\n                    ...writeString(this.subtype),\n                    0x00, // --- contentSize content below ---\n                    ...writeBytes(this.value)\n                ]);\n        }\n    }\n}\n\nclass EnumProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n    type = \"EnumProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        this.type = \"EnumProperty\";\n        savReader.readUInt32(); // contentSize\n        savReader.readBytes(EnumProperty.padding.length);\n        this.enum = savReader.readString();\n        savReader.readBytes(1);\n        this.value = savReader.readString();\n    }\n\n    toBytes() {\n\n        const contentSize = 4 + this.value.length + 1;\n\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeUint32(contentSize),\n            ...EnumProperty.padding,\n            ...writeString(this.enum),\n            0x00,\n            ...writeString(this.value)\n        ]);\n    }\n}\n\nclass FloatProperty {\n    static padding = new Uint8Array([\n        0x04, // ?\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n    ]);\n    type = \"FloatProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        savReader.readBytes(FloatProperty.padding.length);\n        this.value = savReader.readFloat32();\n    }\n\n    toBytes() {\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...FloatProperty.padding,\n            ...writeFloat32(this.value)\n        ]);\n    }\n}\n\nclass StructProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n    static unknown = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"StructProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        const contentSize = savReader.readUInt32();\n        savReader.readBytes(4); // padding\n        this.subtype = savReader.readString();\n        savReader.readBytes(17); // unknown\n\n        const contentEndPosition = savReader.offset + contentSize;\n\n        if (this.subtype === \"Guid\") {\n            this.value = savReader.readBytes(16);\n            return this;\n        }\n\n        if (this.subtype === \"DateTime\") {\n            this.value = savReader.readDateTime();\n            return this;\n        }\n\n        this.value = [];\n\n        while (savReader.offset < contentEndPosition) {\n            this.value.push(savReader.readProperty());\n        }\n    }\n\n    toBytes() {\n        if (this.subtype === \"Guid\") {\n            return new Uint8Array([\n                ...writeString(this.name),\n                ...writeString(this.type),\n                ...writeUint32(16),\n                ...StructProperty.padding,\n                ...writeString(\"Guid\"),\n                ...StructProperty.unknown,\n                ...writeBytes(this.value)\n            ]);\n        }\n\n        if (this.subtype === \"DateTime\") {\n            return new Uint8Array([\n                ...writeString(this.name),\n                ...writeString(this.type),\n                ...writeUint32(8),\n                ...StructProperty.padding,\n                ...writeString(\"DateTime\"),\n                ...StructProperty.unknown,\n                ...writeDateTime(this.value)\n            ]);\n        }\n\n        let contentBytes = new Uint8Array(0);\n\n        for (let i = 0; i < this.value.length; i++) {\n\n            if (Array.isArray(this.value[i])) {\n\n                for (let j = 0; j < this.value[i].length; j++) {\n                    assignPrototype(this.value[i][j]);\n                    contentBytes = new Uint8Array([...contentBytes, ...this.value[i][j].toBytes()]);\n                }\n\n            } else {\n                assignPrototype(this.value[i]);\n                contentBytes = new Uint8Array([...contentBytes, ...this.value[i].toBytes()]);\n            }\n        }\n\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeUint32(contentBytes.length),\n            ...StructProperty.padding,\n            ...writeString(this.subtype),\n            ...StructProperty.unknown,\n            ...contentBytes\n        ]);\n    }\n}\n\nclass ArrayProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n    static unknown = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"ArrayProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        const contentSize = savReader.readUInt32();\n        savReader.readBytes(4); // padding\n        this.subtype = savReader.readString();\n        savReader.readBytes(1);\n\n        switch (this.subtype) {\n            case \"StructProperty\":\n                const contentCount = savReader.readUInt32();\n\n                const nameAgain = savReader.readString();\n                if (nameAgain !== this.name) throw new Error();\n\n                const subtypeAgain = savReader.readString();\n                if (subtypeAgain !== this.subtype) throw new Error();\n\n                savReader.readUInt32(); // arraySize\n                savReader.readBytes(4); // padding\n\n                this.genericType = savReader.readString();\n\n                const unknown = savReader.readBytes(17);\n                if (unknown !== \"0000000000000000000000000000000000\") throw new Error();\n\n                this.value = [];\n\n                switch (this.genericType) {\n                    case \"Guid\":\n                        for (let i = 0; i < contentCount; i++) {\n                            this.value.push(savReader.readBytes(16));\n                        }\n                        break;\n\n                    default:\n\n                        for (let i = 0; i < contentCount; i++) {\n                            const structElementInstance = [];\n\n                            let structElementInstanceChildProperty = null;\n\n                            while (!(structElementInstanceChildProperty instanceof NoneProperty)) {\n                                structElementInstanceChildProperty = savReader.readProperty();\n                                structElementInstance.push(structElementInstanceChildProperty);\n\n                            }\n\n                            this.value.push(structElementInstance);\n                        }\n                }\n\n                break;\n\n            default:\n                this.value = savReader.readBytes(contentSize);\n        }\n    }\n\n    toBytes() {\n        const contentCount = this.value.length;\n        let byteArrayContent = new Uint8Array(0);\n\n        let contentSize;\n\n        switch (this.subtype) {\n            case \"StructProperty\":\n\n                switch (this.genericType) {\n                    case \"Guid\":\n                        for (let i = 0; i < contentCount; i++) {\n                            byteArrayContent = new Uint8Array([...byteArrayContent, ...writeBytes(this.value[i])]);\n                        }\n                        break;\n\n                    default:\n                        for (let i = 0; i < contentCount; i++) {\n\n                            if (Array.isArray(this.value[i])) {\n                                for (let j = 0; j < this.value[i].length; j++) {\n                                    assignPrototype(this.value[i][j]);\n                                    byteArrayContent = new Uint8Array([...byteArrayContent, ...this.value[i][j].toBytes()]);\n                                }\n                            } else {\n                                assignPrototype(this.value[i]);\n                                byteArrayContent = new Uint8Array([...byteArrayContent, ...this.value[i].toBytes()]);\n                            }\n                        }\n                }\n\n                contentSize =\n                    4\n                    + 4 + this.name.length + 1\n                    + 4 + this.subtype.length + 1\n                    + 4\n                    + ArrayProperty.padding.length\n                    + 4 + this.genericType.length + 1\n                    + ArrayProperty.unknown.length\n                    + byteArrayContent.length;\n\n                return new Uint8Array([\n                    ...writeString(this.name),\n                    ...writeString(this.type),\n                    ...writeUint32(contentSize),\n                    ...ArrayProperty.padding,\n                    ...writeString(this.subtype),\n                    0x00, // --- contentSize content below ---\n                    ...writeUint32(contentCount),\n                    ...writeString(this.name),\n                    ...writeString(this.subtype),\n                    ...writeUint32(byteArrayContent.length),\n                    ...ArrayProperty.padding,\n                    ...writeString(this.genericType),\n                    ...ArrayProperty.unknown,\n                    ...byteArrayContent\n                ]);\n\n            default:\n                contentSize = this.value.length / 2;\n                return new Uint8Array([\n                    ...writeString(this.name),\n                    ...writeString(this.type),\n                    ...writeUint32(contentSize),\n                    ...ArrayProperty.padding,\n                    ...writeString(this.subtype),\n                    0x00, // --- contentSize content below ---\n                    ...writeBytes(this.value)\n                ]);\n        }\n    }\n}\n\nclass MulticastInlineDelegateProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00]);\n    static unknown = new Uint8Array([0x01, 0x00, 0x00, 0x00]);\n    type = \"MulticastInlineDelegateProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        savReader.readUInt32(); // contentSize\n        savReader.readBytes(5); // padding\n        savReader.readBytes(4); // unknown\n        this.object_name = savReader.readString();\n        this.function_name = savReader.readString();\n    }\n\n    toBytes() {\n        const contentSize =\n            MulticastInlineDelegateProperty.unknown.length\n            + 4 + this.object_name.length + 1\n            + 4 + this.function_name.length + 1;\n\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeUint32(contentSize),\n            ...MulticastInlineDelegateProperty.padding,\n            ...MulticastInlineDelegateProperty.unknown,\n            ...writeString(this.object_name),\n            ...writeString(this.function_name)\n        ]);\n    }\n}\n\nclass MapProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n    type = \"MapProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        savReader.readUInt32(); // contentSize\n        savReader.readBytes(4); // padding\n        this.keyType = savReader.readString();\n        this.valueType = savReader.readString();\n        savReader.readBytes(1);\n\n        const tempMap = new Map();\n        savReader.readBytes(4); // padding\n        const contentCount = savReader.readUInt32();\n\n        for (let i = 0; i < contentCount; i++) {\n\n            let currentKey = null;\n            let currentValue = null;\n\n            switch (this.keyType) {\n                case \"StructProperty\":\n                    currentKey = savReader.readBytes(16);\n                    break;\n\n                case \"IntProperty\":\n                    currentKey = savReader.readInt32();\n                    break;\n\n                default:\n                    throw new Error(\"Key Type not implemented: \" + this.keyType);\n            }\n\n            switch (this.valueType) {\n\n                case \"StructProperty\":\n                    currentValue = [];\n                    let prop = null;\n\n                    while (!(prop instanceof NoneProperty)) {\n                        prop = savReader.readProperty();\n                        currentValue.push(prop);\n                    }\n                    break;\n\n                case \"IntProperty\":\n                    currentValue = savReader.readInt32();\n                    break;\n\n                case \"FloatProperty\":\n                    currentValue = savReader.readFloat32();\n                    break;\n\n                case \"BoolProperty\":\n                    currentValue = savReader.readBoolean();\n                    break;\n\n                default:\n                    throw new Error(\"Value Type not implemented: \" + this.valueType);\n            }\n\n            tempMap.set(currentKey, currentValue);\n\n        }\n\n        this.value = Array.from(tempMap.entries());\n    }\n\n    toBytes() {\n\n        let byteArrayContent = new Uint8Array(0);\n\n        const tempMap = new Map(this.value);\n\n        for (let [currentKey, currentValue] of tempMap) {\n\n            switch (this.keyType) {\n                case \"StructProperty\":\n                    byteArrayContent = new Uint8Array([...byteArrayContent, ...writeBytes(currentKey)]);\n                    break;\n\n                case \"IntProperty\":\n                    byteArrayContent = new Uint8Array([...byteArrayContent, ...writeInt32(currentKey)]);\n                    break;\n\n                default:\n                    throw new Error(\"Key Type not implemented: \" + this.keyType);\n            }\n\n            switch (this.valueType) {\n\n                case \"StructProperty\":\n                    for (let i = 0; i < currentValue.length; i++) {\n                        assignPrototype(currentValue[i]);\n                        byteArrayContent = new Uint8Array([...byteArrayContent, ...currentValue[i].toBytes()]);\n                    }\n                    break;\n\n                case \"IntProperty\":\n                    byteArrayContent = new Uint8Array([...byteArrayContent, ...writeInt32(currentValue)]);\n                    break;\n\n                case \"FloatProperty\":\n                    byteArrayContent = new Uint8Array([...byteArrayContent, ...writeFloat32(currentValue)]);\n                    break;\n\n                case \"BoolProperty\":\n                    if (currentValue === true) {\n                        byteArrayContent = new Uint8Array([...byteArrayContent, 0x01]);\n                    } else {\n                        byteArrayContent = new Uint8Array([...byteArrayContent, 0x00]);\n                    }\n                    break;\n\n                default:\n                    throw new Error(\"Value Type not implemented: \" + this.valueType);\n            }\n\n        }\n\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeUint32(4 + 4 + byteArrayContent.length),\n            ...MapProperty.padding,\n            ...writeString(this.keyType),\n            ...writeString(this.valueType),\n            ...MapProperty.padding,\n            0x00,\n            ...writeUint32(tempMap.size),\n            ...byteArrayContent\n        ]);\n    }\n}\n\nclass SetProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00]);\n    type = \"SetProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        const contentSize = savReader.readUInt32();\n        savReader.readBytes(4); // padding\n        this.subtype = savReader.readString();\n        savReader.readBytes(1);\n\n        if (this.subtype === \"StructProperty\") {\n\n            savReader.readBytes(4); // padding\n\n            const contentCount = savReader.readUInt32();\n            this.value = [];\n            for (let i = 0; i < contentCount; i++) {\n                this.value.push(savReader.readBytes(16));\n            }\n            return this;\n        }\n\n        this.value = savReader.readBytes(contentSize);\n    }\n\n    toBytes() {\n        if (this.subtype === \"StructProperty\") {\n\n            const contentCount = this.value.length;\n            let byteArrayContent = new Uint8Array(0);\n\n            for (let i = 0; i < contentCount; i++) {\n                byteArrayContent = new Uint8Array([...byteArrayContent, ...writeBytes(this.value[i])]);\n            }\n\n            return new Uint8Array([\n                ...writeString(this.name),\n                ...writeString(this.type),\n                ...writeUint32(4 + 4 + byteArrayContent.length),\n                ...SetProperty.padding,\n                ...writeString(this.subtype),\n                0x00,\n                ...SetProperty.padding,\n                ...writeUint32(contentCount),\n                ...byteArrayContent\n            ]);\n        }\n\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeUint32(this.value.length / 2),\n            ...SetProperty.padding,\n            ...writeString(this.subtype),\n            0x00,\n            ...writeBytes(this.value)\n        ]);\n    }\n}\n\nclass ObjectProperty {\n    static padding = new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00]);\n    type = \"ObjectProperty\";\n\n    constructor(name, savReader) {\n        this.name = name;\n        savReader.readUInt32(); // contentSize\n        savReader.readBytes(5); // padding\n        this.value = savReader.readString();\n    }\n\n    toBytes() {\n        const contentSize = 4 + this.value.length + 1;\n\n        return new Uint8Array([\n            ...writeString(this.name),\n            ...writeString(this.type),\n            ...writeUint32(contentSize),\n            ...ObjectProperty.padding,\n            ...writeString(this.value)\n        ]);\n    }\n}\n\nmodule.exports = {\n    assignPrototype,\n\n    UInt32Property,\n    StrProperty,\n    NameProperty,\n    ByteProperty,\n    EnumProperty,\n    SetProperty,\n    StructProperty,\n    ObjectProperty,\n    HeaderProperty,\n    NoneProperty,\n    FloatProperty,\n    FileEndProperty,\n    BoolProperty,\n    IntProperty,\n    MapProperty,\n    MulticastInlineDelegateProperty,\n    ArrayProperty\n};\n\n\n//# sourceURL=webpack://gvas-json-converter/./src/properties.js?");

/***/ }),

/***/ "./src/sav-reader.js":
/*!***************************!*\
  !*** ./src/sav-reader.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {\n    HeaderProperty,\n    FileEndProperty,\n    NoneProperty,\n    BoolProperty,\n    IntProperty,\n    UInt32Property,\n    FloatProperty,\n    EnumProperty,\n    StructProperty,\n    ArrayProperty,\n    MulticastInlineDelegateProperty,\n    MapProperty,\n    SetProperty,\n    ObjectProperty,\n    StrProperty,\n    NameProperty,\n    ByteProperty\n} = __webpack_require__(/*! ./properties */ \"./src/properties.js\");\n\n// https://stackoverflow.com/a/50868276\nfunction arrayBufferToHexString(arrayBuffer) {\n    return [...new Uint8Array(arrayBuffer)].reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\n\nclass SavReader {\n\n    constructor(fileArrayBuffer) {\n        this.offset = 0;\n        this.fileArrayBuffer = fileArrayBuffer;\n        this.fileSize = fileArrayBuffer.byteLength;\n        this.dataView = new DataView(fileArrayBuffer);\n    }\n\n    readWholeBuffer() {\n        const output = [];\n\n        // this.logProgress();\n\n        const headerProperty = this.readHeader();\n        console.log(JSON.stringify(headerProperty, null, 2));\n        output.push(headerProperty);\n        // this.logProgress();\n\n        while (!this.hasFinished()) {\n            const nextProperty = this.readProperty();\n            console.log(JSON.stringify(nextProperty, null, 2));\n            output.push(nextProperty);\n            // this.logProgress();\n        }\n\n        return output;\n    }\n\n    hasFinished() {\n        return this.offset === this.fileSize;\n    }\n\n    // logProgress() {\n    //     console.log(\"Progress: \" + Number((this.offset / this.fileSize) * 100).toFixed(2) + \"%\");\n    // }\n\n    readHeader() {\n        return new HeaderProperty(this);\n    }\n\n    readProperty() {\n\n        if (this.offset + FileEndProperty.bytes.length === this.fileSize) {\n            const assumedFileEnd = new Uint8Array(this.fileArrayBuffer.slice(this.offset, this.offset + FileEndProperty.bytes.length));\n\n            if (assumedFileEnd.every((value, index) => value === FileEndProperty.bytes[index])) {\n                this.offset += FileEndProperty.bytes.length;\n                return new FileEndProperty();\n            }\n        }\n\n        const name = this.readString();\n\n        switch (name) {\n            case \"None\":\n                return new NoneProperty();\n        }\n\n        const type = this.readString();\n\n        switch (type) {\n            case \"BoolProperty\":\n                return new BoolProperty(name, this);\n            case \"IntProperty\":\n                return new IntProperty(name, this);\n            case \"UInt32Property\":\n                return new UInt32Property(name, this);\n            case \"StrProperty\":\n                return new StrProperty(name, this);\n            case \"NameProperty\":\n                return new NameProperty(name, this);\n            case \"ByteProperty\":\n                return new ByteProperty(name, this);\n            case \"EnumProperty\":\n                return new EnumProperty(name, this);\n            case \"FloatProperty\":\n                return new FloatProperty(name, this);\n            case \"StructProperty\":\n                return new StructProperty(name, this);\n            case \"ArrayProperty\":\n                return new ArrayProperty(name, this);\n            case \"MulticastInlineDelegateProperty\":\n                return new MulticastInlineDelegateProperty(name, this);\n            case \"MapProperty\":\n                return new MapProperty(name, this);\n            case \"SetProperty\":\n                return new SetProperty(name, this);\n            case \"ObjectProperty\":\n                return new ObjectProperty(name, this);\n            default:\n                console.log(this.offset + FileEndProperty.bytes.length)\n                throw new Error(\"Unknown property type: \" + type);\n        }\n    }\n\n    readString() {\n        const size = this.dataView.getUint32(this.offset, true);\n        this.offset += 4;\n\n        const string = new TextDecoder().decode(this.fileArrayBuffer.slice(this.offset, this.offset + size - 1));\n        this.offset += size;\n\n        return string;\n    }\n\n    readBoolean() {\n        const boolean = Boolean(this.dataView.getUint8(this.offset));\n        this.offset += 1;\n        return boolean;\n    }\n\n    readFloat32() {\n        const float = this.dataView.getFloat32(this.offset, true);\n        this.offset += 4;\n        return float;\n    }\n\n    readInt16() {\n        const int = Number(this.dataView.getInt16(this.offset, true));\n        this.offset += 2;\n        return int;\n    }\n\n    readInt32() {\n        const int = Number(this.dataView.getInt32(this.offset, true));\n        this.offset += 4;\n        return int;\n    }\n\n    readUInt32() {\n        const int = Number(this.dataView.getUint32(this.offset, true));\n        this.offset += 4;\n        return int;\n    }\n\n    readDateTime() {\n        const ticksBigInt = this.dataView.getBigUint64(this.offset, true);\n        this.offset += 8;\n        return new Date(Number(ticksBigInt / 10000n) + new Date(\"0001-01-01T00:00:00Z\").getTime());\n    }\n\n    readBytes(numberOfBytes) {\n        const bytes = arrayBufferToHexString(this.fileArrayBuffer.slice(this.offset, this.offset + numberOfBytes));\n        this.offset += numberOfBytes;\n        return bytes;\n    }\n\n}\n\nmodule.exports = {SavReader};\n\n\n//# sourceURL=webpack://gvas-json-converter/./src/sav-reader.js?");

/***/ }),

/***/ "./src/sav-writer.js":
/*!***************************!*\
  !*** ./src/sav-writer.js ***!
  \***************************/
/***/ ((module) => {

eval("function writeInt16(value) {\n    const array = new Uint8Array(2);\n    new DataView(array.buffer).setInt16(0, value, true);\n\n    return array;\n}\n\nfunction writeInt32(value) {\n    const array = new Uint8Array(4);\n    new DataView(array.buffer).setInt32(0, value, true);\n\n    return array;\n}\n\nfunction writeUint32(value) {\n    const array = new Uint8Array(4);\n    new DataView(array.buffer).setUint32(0, value, true);\n\n    return array;\n}\n\nfunction writeFloat32(value) {\n    const array = new Uint8Array(4);\n    new DataView(array.buffer).setFloat32(0, value, true);\n\n    return array;\n}\n\nfunction writeString(string) {\n    const stringSize = writeUint32(string.length + 1);\n    const stringArray = new TextEncoder().encode(string);\n\n    return new Uint8Array([...stringSize, ...stringArray, 0x00]);\n}\n\nfunction writeDateTime(dateTimeString) {\n    const date = new Date(dateTimeString);\n    const array = new Uint8Array(8);\n    const ticks = (BigInt(date.getTime()) * 10000n) + 621355968000000000n;\n\n    new DataView(array.buffer).setBigUint64(0, ticks, true);\n\n    return array;\n}\n\n// https://stackoverflow.com/a/50868276\nfunction writeBytes(hexString) {\n    return Uint8Array.from(hexString.match(/../g).map((byte) => parseInt(byte, 16)));\n}\n\nmodule.exports = {\n    writeString, writeInt16, writeInt32, writeUint32, writeFloat32, writeDateTime, writeBytes\n};\n\n\n//# sourceURL=webpack://gvas-json-converter/./src/sav-writer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.js");
/******/ 	
/******/ })()
;